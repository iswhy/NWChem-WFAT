c=================================================
c=================================================
      subroutine mewfat_print_dyson(rtdb, geom, bas, n0, sx,
     &           g_mo0, g_mo1, oskel)

      implicit none
#include "rtdb.fh"
#include "errquit.fh"
#include "mafdecls.fh"      
      integer rtdb
      integer geom
      integer bas
      integer n0(2)
      integer sx
      integer g_mo0(2)
      integer g_mo1(2)
      logical oskel

      character*8 unit
      logical ds_print, isnorm
      integer np(3), i
      double precision xr(2), yr(2), zr(2), xr0(2), yr0(2), zr0(2)

      double precision wfat_convert_length
      external wfat_convert_length
      

      if (.not. rtdb_get(rtdb, 'mewfat:dyson_print', mt_log, 
     &     1, ds_print)) call errquit('MEWFAT: Cannot read '//
     &     'dyson_print from RTDB', 67, RTDB_ERR)
      if (ds_print) then
         if (.not. rtdb_get(rtdb, 'mewfat:dyson_print_npoint', mt_int,
     &        3, np)) call errquit('MEWFAT: Cannot read '//
     &        'dyson_print_npoint from RTDB', 68, RTDB_ERR)
         if (.not. rtdb_get(rtdb, 'mewfat:dyson_print_xrange', mt_dbl,
     &        2, xr0)) call errquit('MEWFAT: Cannot read '//
     &        'dyson_print_xrange from RTDB', 69, RTDB_ERR)
         if (.not. rtdb_get(rtdb, 'mewfat:dyson_print_yrange', mt_dbl,
     &        2, yr0)) call errquit('MEWFAT: Cannot read '//
     &        'dyson_print_yrange from RTDB', 70, RTDB_ERR)
         if (.not. rtdb_get(rtdb, 'mewfat:dyson_print_zrange', mt_dbl,
     &        2, zr0)) call errquit('MEWFAT: Cannot read '//
     &        'dyson_print_zrange from RTDB', 71, RTDB_ERR)

         if (.not. rtdb_cget(rtdb, 'mewfat:dyson_print_unit', 1, unit))
     &        call errquit('MEWFAT: Cannot read dyson_print_unit '//
     &        'from RTDB', 72, RTDB_ERR)
         if (.not. rtdb_get(rtdb, 'mewfat:dyson_print_isnorm', mt_log,
     &        1, isnorm)) call errquit('MEWFAT: Cannot read '//
     &        'dyson_print_isnorm from RTDB', 71, RTDB_ERR)
         
         do i = 1, 2
            xr(i) = wfat_convert_length(unit, xr0(i), 'bohr')
            yr(i) = wfat_convert_length(unit, yr0(i), 'bohr')
            zr(i) = wfat_convert_length(unit, zr0(i), 'bohr')
         enddo
         
         call mewfat_cube_dyson(geom, bas, np, unit, xr, yr, zr, n0, sx,
     &        g_mo0, g_mo1, isnorm, oskel)
      endif

      end
c=================================================


c=================================================
c=================================================
      subroutine mewfat_cube_dyson(geom, bas, np, unit, xr, yr, zr, 
     &     n0, sx, g_mo0, g_mo1, isnorm, oskel)

      implicit none
#include "errquit.fh"
#include "stdio.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
#include "geom.fh"
      integer geom
      integer bas
      integer np(3)
      character*8 unit
      double precision xr(2), yr(2), zr(2)
      integer n0(2)
      integer sx
      integer g_mo0(2)
      integer g_mo1(2)
      logical isnorm
      logical oskel

      character*12 s
      character*255 fname
      character*16 tag
      integer iunit, natom, i, nb, is, i_ovl, g_ovl(2), npcf, nn, nsc
      integer sy, nmo, ix, iy, iz, j, j1, j2, i_ph, ndid
      integer l_ovl, l_pc, l_iv, l_sc, l_mo, l_b0, l_ph
      integer k_ovl, k_pc, k_iv, k_sc, k_mo, k_b0, k_ph
      double precision dx(3), dy(3), dz(3), orig(3), atp(3), zn, rcf
      double precision vpt(3), dummy1, dummy2, dummy3, dyson, norm
      parameter(iunit=40)

      integer ga_create_atom_blocked
      external ga_create_atom_blocked


      call ga_sync()
      ndid = ga_nodeid()
      call util_file_name('cube', .false., .false., fname)
      if (ndid==0) open(iunit, file=fname, action='write')
      if (ndid==0) write(iunit, '(2x, a)')
     &     "Cube file generated by NWChem's WFAT module"
      s = 'Unnormalized'
      if (isnorm) s = 'Normalized'
      if (ndid==0) write(iunit, '(2x, a)')
     &     trim(adjustl(s))//" Dyson orbital cube file"

      
c     ==== No. of atoms and origin ====
      if (.not. geom_ncent(geom, natom))
     &     call errquit('MEWFAT: Getting natom failed', 27, GEOM_ERR)
      orig = (/ xr(1), yr(1), zr(1) /)
      if (ndid==0) write(iunit, '(2x, i4, 3es13.5)') natom, orig


c     ==== No. of voxels ====
      dx = 0.0d0
      dy = 0.0d0
      dz = 0.0d0
      dx(1) = (xr(2) - xr(1)) / (np(1) - 1)
      dy(2) = (yr(2) - yr(1)) / (np(2) - 1)
      dz(3) = (zr(2) - zr(1)) / (np(3) - 1)
      if (ndid==0) write(iunit, '(2x, i4, 3es13.5)') np(1), dx
      if (ndid==0) write(iunit, '(2x, i4, 3es13.5)') np(2), dy
      if (ndid==0) write(iunit, '(2x, i4, 3es13.5)') np(3), dz


c     ==== Atomic coordinates ====
      do i = 1, natom
         if (.not. geom_cent_get(geom, i, tag, atp, zn))
     &        call errquit('WFAT: Getting znuc failed', 52, GEOM_ERR)
         if (ndid==0) write(iunit, '(2x, i4, 4es13.5)')
     &        int(zn), 0.0d0, atp
      enddo


c     ==== Calculate overlap between MO's ====
      if (.not. bas_numbf(bas, nb))
     &     call errquit('MEWFAT: Getting nbas failed in ', 85, UERR)
      do is = 1, 2
         g_ovl(is) = ga_create_atom_blocked(geom, bas, 'MO_overlap')
         call ga_zero(g_ovl(is))
      enddo
      call mewfat_calc_moovl(geom, bas, oskel, g_mo0, g_mo1, g_ovl)
      if (.not. ma_alloc_get(mt_dbl, nb*nb*2, 'moov', l_ovl, k_ovl))
     &     call errquit('MEWFAT: Cannot allocate moov', 36, MA_ERR)
      do is = 1, 2
         i_ovl = k_ovl + (is-1)*nb*nb
         call ga_get(g_ovl(is), 1, nb, 1, nb, dbl_mb(i_ovl), nb)
      enddo
      

c     ==== Calculate P det. coefficients ====
      if (ndid==0) write(luout, '("heref0")')
      npcf = n0(sx)
      if (.not. ma_alloc_get(mt_dbl, npcf, 'pcf', l_pc, k_pc))
     &     call errquit('MEWFAT: Cannot allocate pcf.', 29, MA_ERR)
      if (n0(sx) == 1) then
         dbl_mb(k_pc) = 1.0d0
      else
         nn = maxval(n0)
         if (.not. ma_alloc_get(mt_int, nn, 'ipvt', l_iv, k_iv)) 
     &        call errquit('MEWFAT: failed to allocate ipvt', 0, MA_ERR)
         if (ndid==0) write(luout, '("heref1", i5)') nn
         nsc = nn*(nn+1)
         if (.not. ma_alloc_get(mt_dbl, nsc, 'scratch', l_sc, k_sc))
     &        call errquit('MEWFAT: Cannot allocate scratch.',
     &        1, MA_ERR)
         if (ndid==0) write(luout, '("heref2", i5)') nsc
         call mewfat_calc_pcf(sx, n0, nb, dbl_mb(k_ovl), dbl_mb(k_sc),
     &        int_mb(k_iv), dbl_mb(k_pc))
      endif
      

c     ==== Calculate R det. coefficients ====
      if (sx==1) sy = 2
      if (sx==2) sy = 1
      if (n0(sy) == 0) then
         rcf = 1.0d0
      else
         call mewfat_calc_rcf(sy, n0, nb, dbl_mb(k_ovl), dbl_mb(k_sc),
     &        int_mb(k_iv), rcf)
      endif
      if (ndid==0) write(luout, '("heref3")')

      
c     ==== Get MO coefficients ====
      nmo = nb * n0(sx)
      if (ndid==0) write(luout, '("heref4 ", 2i5)') nb, n0(sx)
      if (.not. ma_alloc_get(mt_dbl, nmo, 'mo', l_mo, k_mo))
     &     call errquit('MEWFAT: Cannot allocate mo.', 75, MA_ERR)
      call ga_get(g_mo0(sx), 1, nb, 1, n0(sx), dbl_mb(k_mo), nb)

      
c     ==== Evaluate and print Dyson orbital ====
      if (.not. ma_alloc_get(mt_dbl, nb, 'bval', l_b0, k_b0))
     &     call errquit('MEWFAT: Cannot allocate bval.', 75, MA_ERR)
      if (.not. ma_alloc_get(mt_dbl, n0(sx), 'phi', l_ph, k_ph))
     &     call errquit('MEWFAT: Cannot allocate phi.', 18, MA_ERR)
      do ix = 1, np(1)
         do iy = 1, np(2)
            do iz = 1, np(3)
c              ==== Evaluate basis functions ====
               vpt(1) = xr(1) + (ix-1)*dx(1)
               vpt(2) = yr(1) + (iy-1)*dy(2)
               vpt(3) = zr(1) + (iz-1)*dz(3)
               call wfat_eval_basis_1pt(geom, bas, 0, vpt,
     &              dbl_mb(k_b0), dummy1, dummy2, dummy3)


c              ==== Evaluate MO's in sx-spin channel ====
               do j = 1, n0(sx)
                  j1 = k_mo + (j-1)*nb
                  j2 = j1 + nb - 1
                  i_ph = k_ph + j - 1
                  dbl_mb(i_ph) = sum(dbl_mb(k_b0:k_b0+nb-1) *
     &                           dbl_mb(j1:j2))
               enddo
               
               
c              ==== Evaluate Dyson orbital ====
               call mewfat_eval_dyson(sx, n0, dbl_mb(k_pc), rcf,
     &              dbl_mb(k_ph), dyson)
               if (isnorm) then
                  call mewfat_norm_dyson(sx, n0, dbl_mb(k_pc), rcf,
     &                 norm)
                  dyson = dyson / sqrt(norm)
               endif

               if (ndid==0) write(iunit, '(" ")', advance='no')
               if (ndid==0) write(iunit, '(1x, e13.5)', advance='no')
     &              dyson
               if (mod(iz,6)==0) then
                  if (ndid==0) write(iunit, '(" ")')
               endif
               
            enddo
            if (ndid==0) write(iunit, '(" ")')
         enddo
      enddo
      
      if (ndid==0) close(iunit)


c     ==== Deallocations ====
      do is = 1, 2
         if (.not. ga_destroy(g_ovl(is)))
     &        call errquit('MEWFAT: Cannot destroy MO_overlap.',
     &        47, GA_ERR)
      enddo      
      if (.not. ma_free_heap(l_ovl))
     &     call errquit('MEWFAT: Cannot deallocate moov', 81, MA_ERR)
      if (n0(sx) /= 1) then
         if (.not. ma_free_heap(l_iv))
     &        call errquit('MEWFAT: Cannot deallocate ipvt', 81, MA_ERR)
         if (.not. ma_free_heap(l_sc))
     &        call errquit('MEWFAT: Cannot deallocate scratch', 81,
     &        MA_ERR)
      endif      
      if (.not. ma_free_heap(l_pc))
     &     call errquit('MEWFAT: Cannot deallocate pcf', 81, MA_ERR)
      if (.not. ma_free_heap(l_mo))
     &     call errquit('MEWFAT: Cannot deallocate mo', 81, MA_ERR)
      if (.not. ma_free_heap(l_b0))
     &     call errquit('MEWFAT: Cannot deallocate bval', 81, MA_ERR)
      if (.not. ma_free_heap(l_ph))
     &     call errquit('MEWFAT: Cannot deallocate phi', 81, MA_ERR)


      call ga_sync()
      
      end
c=================================================
      
      
